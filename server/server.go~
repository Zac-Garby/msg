package server

import (
	"log"
	"strings"

	"github.com/gorilla/websocket"
	uuid "github.com/satori/go.uuid"
)

// A Server is a websocket server which handles
// websocket connections from clients.
type Server struct {
	messages chan *message
	clients  map[uuid.UUID]*client
}

// New creates a new server.
func New() *Server {
	s := &Server{
		messages: make(chan *message, 1),
		clients:  make(map[uuid.UUID]*client),
	}

	return s
}

func (s *Server) NewClient(conn *websocket.Conn) error {
	defer conn.Close()

	id := uuid.NewV4()

	s.clients[id] = &client{
		id:       id,
		conn:     conn,
		sentInfo: false,
	}

	for {
		msg := &message{
			sender: s.clients[id],
		}

		if err := conn.ReadJSON(msg); err != nil {
			if strings.Contains(err.Error(), "use of closed network") {
				break
			}

			log.Println("server err: listen:", err)
			break
		}

		s.messages <- msg
	}

	return nil
}

func (s *Server) HandleMessages() {
	for {
		msg := <-s.messages

		switch msg.Type {
		case "client-info":
			data, ok := msg.Data.(map[string]string)
			if ok {
				name, ok := data["name"]
				if !ok {
					break
				}

				room, ok := data["room"]
				if !ok {
					break
				}

				msg.sender.name = name
				msg.sender.room = room
				msg.sender.sentInfo = true
			}

		case "chat":
			broadcast(s, &message{
				Type: "chat",
				Data: map[string]string{
					"sender": msg.sender.name,
					"text":   msg.Data.(string),
				},
			})
		}
	}
}
